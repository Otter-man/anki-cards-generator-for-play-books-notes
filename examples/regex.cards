<<<
# How can you match empty lines?
---
    ^$
`^` match the beginning of the line and `$` match the end (but not the new line `\n` character).
>>>
<<<
# How can you match any character from a list?
---
Using the character class `[...]`.
The `...` represents any list of characters.
Ex: match `a`, `b` or `c`: `[abc]`.
>>>
<<<
# How can you match any character except those on the list?
---
Using the character class with the "negation" symbol `[^...]`.
The `...` represents any list of characters.
Ex: match any characters different to `a`, `b` or `c`: `[^abc]`.
>>>
<<<
# How can you indicate a range of values inside a character class `[...]`?
---
Using the metacharacter `-`.
The dash is only a metacharacter inside a character class `[...]`.
In any other place it match a regular dash.
Ex: to match hexadecimal characters, instead of `[0123456789abcdefABCDEF]`, you can write `[0-9a-fA-F]`.

Note: If a dash is the first character in a character class it is not considered a metacharacter (it cannot represent a range between two characters!).
Ex: match dash and numbers: `[-0-9]`
>>>
<<<
# How can you match any character?
---
Using the metacharacter `.`.
It doesn't include new lines `\n`.

Important: Inside a character class is not a metacharacter, it match the dot.
>>>
<<<
# How to match optional items?
---
The metacharacter `?` is a *quantifier*, that is, it affect the number of times the preceding character can appear in the expression.
With `?`, the preceding character can appear **zero or once**.

Ex: match the English word 'colour' and the American version the same word ('color') with: `colou?r`.
>>>
<<<
# How to match at least one character or more?
---
The metacharacter `+` is a *quantifier*, that is, it affect the number of times the preceding character can appear in the expression.
With `+`, the preceding character can appear **once or more** times.

Ex: match the word 'goal' in a soccer match transcript: `go+al`.
It match `goooooal` with any number of 'o's but not 'gal'.
>>>
<<<
# How to match an optional character or more?
---
The metacharacter `*` is a *quantifier*, that is, it affect the number of times the preceding character can appear in the expression.
With `*`, the preceding character can appear **zero times or more**.
>>>
<<<
# How to match any custom number of repetitions?
---
Using the interval quantifier `{min,max}`.
You can use `{min,}` to specify a minimum but not a maximum.
You can also use `{min}` to specify a exact number of repetitions.

Some equivalences:
 * `.{0,1}` is equivalent to `.?`.
 * `.{1,}` is equivalent to `.+`.
 * `.{0,}` is equivalent to `.\*`.

Ex: match the non-exciting *goals* in a transcript of a soccer match (those 'goals' with less than 10 'o's): `go{1,9}al`.
>>>
<<<
# How to escape characters to match metacharacters?
---
Using the backslash `\`.

Ex 1: match the question mark `\?`.

Ex 2: match the backslash `\\`.
>>>
<<<
# How can you match `"hi"` or `'hi'` without using the pipe `"hi"|'hi'`?

You shouldn't match `"hi'` or `'hi"`, so `["']hi['"]` is not the solution.
---
A possible solution is using backreferences: `(["'])hi\\1`.
The `\\1` references the previous captured text, that is, the `(["'])`.
So if the first character is a `"`, the `\\1` is going to expect another `"`.
If it is a `'`, it's going to expect another `'`.
>>>
<<<
# How can you match a word?
---
Using `\w` that is equivalent to `[a-zA-Z0-9_]`.
>>>
<<<
tags: python
===
# What is a modifier?
---
Letter placed after the closing delimiter of an expression that affects how the expression is compiled.
Ex: match the word *wand* regardless of capitalization: `/wand/i`

In some implementations you indicate the modifiers using the API of the language.
Ex: in Python `re.match("wand", "WaNd", re.I)`.
>>>
<<<
# What does the modifier `\s` does?
---
Changes the behavior of the dot `.` metacharacter to match all characters, including newlines.
>>>
